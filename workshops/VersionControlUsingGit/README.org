#+TITLE: Version Control Using Git
#+OPTIONS: toc:nil num:nil timestamp:nil author:nil
#+REVEAL_ROOT: ../../reveal.js
#+REVEAL_TRANS: slide
#+REVEAL_THEME: black
#+REVEAL_EXTRA_CSS: ../custom.css

* Prerequisites
Basic terminal commands

* Test
#+BEGIN_EXPORT html
<div id="test"></div>
#+END_EXPORT

* Imagining a world without version control systems
** Team members keep different copies of the same project
** Using a messaging service to send files that were changed
** The other person spends some time reviewing the changes
** Manually merge the code
** More back and forth on messaging services
** On completion the boss takes the credit from his co-workers
** Time passes
** Code breaks
** No track of changes
** Code needs fixing or write the project from scratch
** Vicious loop begins

* Aim of VC Systems
#+ATTR_REVEAL: :frag (appear)
- Can keep multiple working states with the help of branches
- Can help in reverting to any change made in the past
- Helps in merging two different branches
- Retains the time and author of a set of changes
- Provides an API to query software history

* Key terms
#+ATTR_REVEAL: :frag (appear)
+ State / Commit / Changeset
+ Branch
+ Remote

* Note
Git commands only work when you are currently inside a directory
having the ~.git/~ subdirectory.

** Dirs where =git= commands work
 If a =.git/= dir is at =~/projects/favproject/.git/= then you can run =git= commands
 from:
 - =~/projects/favproject/= or
 - =~/projects/favproject/subdir/=

** Dirs where =git= commands work
If a =.git/= dir is at =~/projects/favproject/.git/= then you cannot run =git= from:
 - =~/= or
 - =~/favproject/= or
 - =~/projects/favproject/.git/=


* Lets get started
Open terminal and create a new Git repository
#+BEGIN_SRC shell -i :exports code
git init ~/newproject  # make .git/
cd ~/newproject
# Now we can run git commands
#+END_SRC

* Setting up Author details
One time setup:
#+BEGIN_SRC shell :exports code
git config --global user.name  'Ratan Tata'
git config --global user.email 'ratantata@tata.com'
#+END_SRC

* Set up =$EDITOR=
#+BEGIN_SRC shell -i
EDITOR=emacs
#+END_SRC
You can use the following in your =~/.profile= or =~/.bashrc=
#+begin_src shell
export EDITOR=emacs
#+end_src

* A ~Hello, World!~ program in Python
~hello.py~:
#+BEGIN_SRC python -i :exports code :tangle hello.py
print("Hello, World!")
#+END_SRC
Running the script:
#+BEGIN_SRC shell -i :exports code
python3 hello.py
#+END_SRC

* State
A *state* comprises of the /changes/, /timestamp/, /author/, /id/ and /parent id/.

* Creating new states/commits
#+ATTR_REVEAL: :frag (appear)
- First, select which changes will be added to the state
- The /unselected/ ones are part of Git’s *unstaged* changes
- The /selected/ ones are part of Git’s *staged* changes
- Once the selection is done we can *commit* the changes

* ~git status~
Check if files were changed since the last commit. It shows:
#+ATTR_REVEAL: :frag (appear)
- Selected/Staged files
- Unselected/Unstaged files
- Unknown/Untracked files

* Ignoring useless files
To ignore some files we need to add a file called ~.gitignore~:
#+BEGIN_EXAMPLE
*.pyc
__pycache__/
#+END_EXAMPLE

* What files are good to ignore?
#+ATTR_REVEAL: :frag (appear)
+ Binaries
+ External dependencies
+ Build outputs
+ Cache
+ Databases

* How to select/stage files
#+BEGIN_SRC shell -i :exports code
git add hello.c   # add to staging area
#+END_SRC

* How to unstage files
#+BEGIN_SRC shell -i :exports code
git reset HEAD -- hello.c
#+END_SRC

* Commiting the state
Add the state to the history:
#+BEGIN_SRC shell -i
git commit    # Opens your $EDITOR
#+END_SRC
Then type in an appropriate message. Save and exit.

* Tip
#+ATTR_REVEAL: :frag (appear)
*Keep your changes short and commit messages descriptive.*
#+ATTR_REVEAL: :frag (appear)
It is hard to achieve but start from now and hopefully you will start to embrace
it and make others happy.
#+ATTR_REVEAL: :frag (appear)
*Commit often*
#+ATTR_REVEAL: :frag (appear)
This will help you achieve the above.

* Branch
#+ATTR_REVEAL: :frag (appear)
- After commiting, the states become a part of a branch.
- The default branch name is ~master~.
- Helps to create different timelines.
- Technically, it is a pointer to specific commits.

* List all branches
#+BEGIN_SRC shell -i :exports code
git branch -a
#+END_SRC

* Creating a new branch
#+BEGIN_SRC shell -i :exports code
git branch test  # branch from current commit
#+END_SRC

* Switching to a branch
#+BEGIN_SRC shell -i :exports code
git checkout test
#+END_SRC
Now the commits will be added to ~test~ branch.

* =HEAD=
#+ATTR_REVEAL: :frag (appear)
- =HEAD= is a special branch
- Wherever you go =HEAD= follows you
- When you =checkout= to a commit/branch you change position of =HEAD=
- When you add a new commit, =HEAD= moves forward along with the branch to which
  =HEAD= points to

* Change in program
#+BEGIN_SRC python -i :exports code :tangle hello.py
def greetings(name):
    print(f"Hello, {name}!")

if __name__ == '__main__':
    import sys
    greetings(sys.argv[1])
#+END_SRC
Running the program:
#+begin_src shell -i :exports both :results output :cache yes
python3 hello.py "Ratan Tata"
#+end_src

#+RESULTS[1c1bb5cf9981f08eb77cff8cedca12fa7d148851]:
: Hello, World!

* Then?
1. Check if you made any changes
2. Select/Add files
3. Commit

* View the log
#+BEGIN_SRC shell
git log --graph --decorate --abbrev-commit --oneline
#+END_SRC

* Thank you
#+BEGIN_EXPORT html
<script type="text/javascript" src="canvas.js"></script>
#+END_EXPORT
#  LocalWords:  SHA
